# Import Packages & Data

```{python}
import pandas as pd
import numpy as np
import itertools
import random

uconn_data = pd.read_csv('data/in-game-trackman/final_fall_stats.csv')
```

# Data Cleaning & Necessary Information

## Cleaning

```{python}
uconn_data['Name'] = uconn_data['First'] + ' ' + uconn_data['Last']
uconn_data.drop(columns = ['First', 'Last'], inplace = True)

req_data = uconn_data[['Name', 'Prob1B', 'Prob2B', 'Prob3B', 'Prob4B', 'ProbOut']]
```

## Set Player Positions & Starters

```{python}
# players per position
catcher = ['Matt Garbowski', 'Connor Lane', 'Mike Oates', 'Gabriel Tirado']
first_b = ['Maddix Dalena', 'Grant MacArthur', 'Gabriel Tirado']
second_b = ['Ryan Daniels', 'Jack LaRose', 'Bryan Padilla', 'Rob Rispoli']
third_b = ['Tyler Minick', 'Bryan Padilla', 'Jack LaRose']
ss = ['Anthony Belisario', 'Bryan Padilla', 'Rob Rispoli']
left = ['Sam Biller', 'Carter Groen', 'Drew Kron', 'Beau Root', 'Aidan Dougherty']
right = ['Sam Biller', 'Aidan Dougherty', 'Carter Groen', 'Caleb Shpur', 'Drew Kron']
center = ['Sam Biller', 'Drew Kron', 'Beau Root', 'Caleb Shpur']
dh = ['Maddix Dalena', 'Ryan Daniels', 'Matt Garbowski', 'Carter Groen', 'Tyler Minick']

# definite starters
starters = ['Matt Garbowski', 'Maddix Dalena', 'Bryan Padilla', 'Ryan Daniels',
                            'Tyler Minick', 'Caleb Shpur', 'Sam Biller', 'Rob Rispoli']

# possible lineup positions
first_names = ['Matt Garbowski', 'Bryan Padilla', 'Tyler Minick', 'Drew Kron', 'Beau Root', 
                                                    'Caleb Shpur', 'Sam Biller', 'Rob Rispoli']
second_names = ['Matt Garbowski', 'Bryan Padilla', 'Tyler Minick', 'Drew Kron', 
                                        'Beau Root', 'Sam Biller', 'Rob Rispoli']
third_names = ['Matt Garbowski', 'Maddix Dalena', 'Grant MacArthur', 'Jack LaRose', 
                            'Bryan Padilla', 'Tyler Minick', 'Drew Kron', 'Beau Root', 'Sam Biller',
                             'Rob Rispoli', 'Ryan Daniels', 'Connor Lane', 'Gabriel Tirado']
fourth_names = ['Matt Garbowski', 'Maddix Dalena', 'Grant MacArthur', 'Jack LaRose', 
                            'Bryan Padilla', 'Tyler Minick', 'Drew Kron', 'Beau Root', 'Sam Biller',
                             'Rob Rispoli', 'Ryan Daniels', 'Connor Lane', 'Gabriel Tirado']
fifth_names = ['Matt Garbowski', 'Maddix Dalena', 'Beau Root', 'Caleb Shpur', 'Bryan Padilla', 'Tyler Minick',
                            'Ryan Daniels', 'Connor Lane', 'Gabriel Tirado', 'Sam Biller',
                             'Rob Rispoli', 'Mike Oates', 'Grant MacArthur', 'Jack LaRose', 'Drew Kron']
sixth_names = ['Matt Garbowski', 'Maddix Dalena', 'Beau Root', 'Caleb Shpur', 'Tyler Minick',
                            'Ryan Daniels', 'Anthony Belisario', 'Connor Lane', 'Gabriel Tirado', 'Sam Biller',
                                        'Rob Rispoli', 'Mike Oates', 'Grant MacArthur', 'Jack LaRose', 'Drew Kron']
seventh_names = ['Caleb Shpur', 'Ryan Daniels', 'Anthony Belisario', 'Connor Lane', 'Gabriel Tirado',
                    'Sam Biller', 'Carter Groen', 'Rob Rispoli', 'Mike Oates', 'Grant MacArthur', 'Jack LaRose',
                                                                                                    'Drew Kron']
eighth_names = ['Ryan Daniels', 'Anthony Belisario', 'Connor Lane', 'Gabriel Tirado', 
                    'Sam Biller', 'Carter Groen', 'Rob Rispoli', 'Mike Oates', 'Grant MacArthur', 'Jack LaRose',
                                                                                                    'Drew Kron']
ninth_names = ['Ryan Daniels', 'Anthony Belisario', 'Connor Lane', 'Gabriel Tirado',
                        'Carter Groen', 'Mike Oates', 'Grant MacArthur', 'Jack LaRose', 'Drew Kron']
```

## Probabilities & Simulation Preparation

```{python}
# probability assumptions
prob_2ndtohome_single = 0.60
prob_1sttohome_double = 0.45
prob_2to3_double = 0.10

num_games = 100
```

# Monte-Carlo Simulation

```{python}
sample = np.random.choice([0, 1, 2, 3, 4], size = 1, p = [0.4, 0.2, 0.1, 0.1, 0.2])

skeleton_cols = ['Batter', 'Prob1st', 'Prob2nd', 'Prob3rd', 'ProbHome','ProbOut',
                'Result', 'Inning', 'Outs', 'Runner1', 'Runner2', 'Runner3', 'Runs']

skeleton_data = pd.DataFrame(data = [[None] * 13 for _ in range(81)], 
                                                    columns = skeleton_cols)

skeleton_data
```

```{python}
lookup_table = pd.DataFrame({'Number_for_Player': range(1, 20), 
                                        'Player_Name': req_data['Name']})
```

```{python}
c_nums = np.empty(len(catcher))
first_nums = np.empty(len(first_b))
second_nums = np.empty(len(second_b))
third_nums = np.empty(len(third_b))
short_nums = np.empty(len(ss))
left_nums = np.empty(len(left))
center_nums = np.empty(len(center))
right_nums = np.empty(len(right))
dh_nums = np.empty(len(dh))

def fill_lookup(pos, pos_lst):
    for i in range(len(pos_lst)):
        try:
            pos_lst[i] = lookup_table['Player_Name'].tolist().index(pos[i]) + 1
        except ValueError:
            pos_lst[i] = np.nan

fill_lookup(catcher, c_nums)
fill_lookup(first_b, first_nums)
fill_lookup(second_b, second_nums)
fill_lookup(third_b, third_nums)
fill_lookup(ss, short_nums)
fill_lookup(left, left_nums)
fill_lookup(center, center_nums)
fill_lookup(right, right_nums)
fill_lookup(dh, dh_nums)
```

```{python}
comb_grid = pd.DataFrame(
    itertools.product(c_nums, first_nums, second_nums, third_nums, short_nums, 
                                    left_nums, right_nums, center_nums, dh_nums),
    columns=['C_Numbers', 'First_Numbers', 'Second_Numbers', 'Short_Numbers', 
             'Third_Numbers', 'LF_Numbers', 'RF_Numbers', 'CF_Numbers', 'DH_Numbers']
)

comb_grid = comb_grid.values
cols = ['C_Numbers', 'First_Numbers', 'Second_Numbers', 'Short_Numbers', 'Third_Numbers',
                                    'LF_Numbers', 'RF_Numbers', 'CF_Numbers', 'DH_Numbers']

comb_grid = pd.DataFrame(comb_grid, columns = cols)

comb_grid['TestingColumn'] = 'tmp'

comb_grid['TestingColumn'] = comb_grid.iloc[:, :9].apply(lambda row: len(set(row)), axis=1)

comb_grid = comb_grid[comb_grid['TestingColumn'] == 9]
```

```{python}
starters = [lookup_table['Player_Name'].tolist().index(starter) + 1 for starter in starters]

comb_grid['start_test'] = comb_grid.iloc[:, :9].apply(
    lambda row: all(num in row.values for num in starters), axis=1
)

comb_grid = comb_grid[comb_grid['start_test'] == True]

comb_grid.drop(columns = ['start_test', 'TestingColumn'], inplace = True)

comb_grid.columns = ['C', '1B', '2B', 'SS', '3B', 'LF', 'RF', 'CF', 'DH']

comb_grid_text = comb_grid.copy()

for col in comb_grid_text.columns:
    comb_grid_text[col] = comb_grid_text[col].apply(
        lambda num: lookup_table.iloc[int(num) - 1, 1]
    )
```

```{python}
first_permutations = list(itertools.permutations(comb_grid.iloc[0, :].astype(int)))

permutations_expanded = pd.DataFrame(first_permutations)

for i in range(1, comb_grid.shape[0]):
    row_permutations = list(itertools.permutations(comb_grid.iloc[i, :].astype(int)))
    permutations_expanded = pd.concat(
        [permutations_expanded, pd.DataFrame(row_permutations)], ignore_index=True
    )

permutations_expanded.columns = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth',
                                                            'seventh', 'eighth', 'ninth']

permutations_expanded = permutations_expanded.drop_duplicates()
```

```{python}
def map_to_indices(names, lookup_table):
    return lookup_table.loc[lookup_table['Player_Name'].isin(names), 'Number_for_Player'].tolist()

first_opt = map_to_indices(first_names, lookup_table)
second_opt = map_to_indices(second_names, lookup_table)
third_opt = map_to_indices(third_names, lookup_table)
fourth_opt = map_to_indices(fourth_names, lookup_table)
fifth_opt = map_to_indices(fifth_names, lookup_table)
sixth_opt = map_to_indices(sixth_names, lookup_table)
seventh_opt = map_to_indices(seventh_names, lookup_table)
eighth_opt = map_to_indices(eighth_names, lookup_table)
ninth_opt = map_to_indices(ninth_names, lookup_table)

permutations_condensed = permutations_expanded[
    (permutations_expanded['first'].isin(first_opt)) &
    (permutations_expanded['second'].isin(second_opt)) &
    (permutations_expanded['third'].isin(third_opt)) &
    (permutations_expanded['fourth'].isin(fourth_opt)) &
    (permutations_expanded['fifth'].isin(fifth_opt)) &
    (permutations_expanded['sixth'].isin(sixth_opt)) &
    (permutations_expanded['seventh'].isin(seventh_opt)) &
    (permutations_expanded['eighth'].isin(eighth_opt)) &
    (permutations_expanded['ninth'].isin(ninth_opt))
]

permutations_condensed
```

```{python}
def process_event(cur_row, prev_row):
    # last out of the game -- nothing left to update
    if prev_row['Inning'] == 9 and prev_row['Outs'] == 3:
        cur_row['Inning'] = 9
        cur_row['Outs'] = 9
        cur_row['Runs'] = prev_row['Runs']

    # no hit
    elif cur_row['Result'] == 0:
        if prev_row['Outs'] != 3:
            cur_row['Outs'] = 1 + prev_row['Outs']
            cur_row[9:] = prev_row[9:]
            cur_row['Inning'] = prev_row['Inning']
        else:
            cur_row['Outs'] = 1
            cur_row[9:12] = 0
            cur_row['Runs'] = prev_row['Runs']
            cur_row['Inning'] = 1 + prev_row['Inning'] 

    # single 
    elif cur_row['Result'] == 1:
        if prev_row['Outs'] != 3:
            cur_row['Outs'] = prev_row['Outs']
            cur_row['Inning'] = prev_row['Inning']
        else:
            cur_row['Outs'] = 0
            cur_row['Inning'] = 1 + prev_row['Inning']
            cur_row[9:12] = 0
            cur_row['Runs'] = prev_row['Runs']

        # no runners on 
        if prev_row['Runner1'] == 0:
            cur_row['Runner1'] = 1
            cur_row[10:12] = 0
            cur_row['Runs'] = prev_row['Runs']
        
        else:
            cur_row.iloc[9:] = update_cols(prev_row, 1, [1 - prob_2ndtohome_single, prob_2ndtohome_single])

        # double
        

def update_cols(prev_row, hit, prob_wts):
    r1 = prev_row['Runner1']
    r2 = prev_row['Runner2']
    r3 = prev_row['Runner3']
    runs = prev_row['Runs']

    if hit == 1:
        if r1 == 0: return 1, 0, 0, runs
        elif r1 == 2 and r2 == 0: 
            r1 = random.choices([3, 1], weights = prob_wts, k = 1)[0]
            return 3, 1, 0, runs if r1 == 3 else 1, 0, 0, 1 + runs
        elif r1 == 2 and r2 == 1:
            r1 = random.choices([3, 2], weights = prob_wts, k = 1)[0]
            return 3, 2, 1, runs if r1 == 3 else 2, 1, 0, 1 + runs 
        elif r1 == 3 and r2 == 0: return 1, 0, 0, 1 + runs
        elif r1 == 3 and r2 == 1: 2, 1, 0, 1 + runs
        elif r1 == 3 and r2 == 2:
            r1 = random.choices([3, 1], weights = prob_wts, k = 1)[0]
            return 3, 1, 0, 1 + runs if r1 == 3 else 1, 0, 0, 2 + runs
        elif r3 == 1:
            r1 = random.choices([3, 2], weights = prob_wts, k = 1)[0]
            return 3, 2, 1, 1 + runs if r1 == 3 else 2, 1, 0, 2 + runs
        else:
            return 'error', 'error', 'error', 'error'

```

```{python}
np.random.seed(1)

run_total = pd.DataFrame({'Runs': np.zeros(num_games)})

for i in range(len(permutations_condensed)):
    indices = permutations_condensed.iloc[i, :9].values - 1  # Adjust for 0-based index
    batter_vec = req_data.iloc[indices, 0].values
    prob_vecs = req_data.iloc[indices, 1:6].values

    skeleton_data[['Batter', 'Prob1st', 'Prob2nd', 'Prob3rd', 'ProbHome', 'ProbOut']] = \
        np.tile(np.column_stack([batter_vec, prob_vecs]), (9, 1))

    # normalize data so probabilities add to one
    prob_cols = ['Prob1st', 'Prob2nd', 'Prob3rd', 'ProbHome', 'ProbOut']
    skeleton_data[prob_cols] = skeleton_data[prob_cols].div(skeleton_data[prob_cols].sum(axis = 1), axis = 0)

    for j in range(1):
        skeleton_data_tmp = skeleton_data.copy()

        skeleton_data_tmp[prob_cols] = skeleton_data_tmp[prob_cols].apply(pd.to_numeric, errors = 'coerce')
        skeleton_data_tmp['Result'] = skeleton_data_tmp[prob_cols].apply(
        lambda row: np.random.choice([0, 1, 2, 3, 4], size = 1, p = row.values)[0], axis=1
    )

        # initial states
        skeleton_data_tmp['Inning'] = 1
        skeleton_data_tmp['Runs'] = 0
        skeleton_data_tmp['Outs'] = 0

        # possible results (out, single, double, triple, homerun)
        res_0 = skeleton_data_tmp['Result'][0] == 0
        res_1 = skeleton_data_tmp['Result'][0] == 1
        res_2 = skeleton_data_tmp['Result'][0] == 2
        res_3 = skeleton_data_tmp['Result'][0] == 3
        res_4 = skeleton_data_tmp['Result'][0] == 4

        # fill in first row (first at-bat in first inning)
        # increment outs to one when result is an out
        skeleton_data_tmp.loc[0, 'Outs'] = np.where(res_0, 1, np.where(res_1 | res_2 | res_3, 0, 
                                                                    skeleton_data_tmp['Outs'][0]))

        # increment runs to one when result is a homerun
        skeleton_data_tmp.loc[0, 'Runs'] = np.where(res_4, 1, skeleton_data_tmp['Runs'][0])

        # increment runner appropriately when result is a hit
        skeleton_data_tmp.loc[0, 'Runner1'] = np.where(res_1, 1, np.where(res_2, 2, 
                                                                    np.where(res_3, 3, 0)))

        # set runner placements to zero for a homerun
        skeleton_data_tmp.iloc[0, 8:12] = np.where(res_4, 0, skeleton_data_tmp.iloc[0, 8:12])

        for k in range(1, len(skeleton_data_tmp)):
            prev_row = skeleton_data_tmp.iloc[k - 1]
            cur_row = skeleton_data_tmp.iloc[k].copy()

            # ninth inning, third out
            if (prev_row['Inning'] == 9 and prev_row['Outs'] == 3):
                skeleton_data_tmp.loc[k, 'Inning'] = 9
                skeleton_data_tmp.loc[k, 'Outs'] = 3
                skeleton_data_tmp.loc[k, 'Runs'] = prev_row['Runs']
            else:
                skeleton_data_tmp.iloc[k] = process_event(cur_row, 
                                                            prev_row)

skeleton_data_tmp
```